<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>

    <button onclick="startInterval()">2초마다 현재 시간을 표시</button>
    <button onclick="cancelInterval()">시간 갱신 중지</button>

    <input type="\">
    <button onclick="PaddleSpeedUp(1)">Paddle Speed +</button>
    <button onclick="PaddleSpeedDown(1)">Paddle Speed -</button>

    <p id="date"></p>
    <p id="timer"></p>

    <script>
        function startInterval() {
            timeoutId = setInterval(printCurrentDate, 2000);
        }
        function cancelInterval() {
            clearInterval(timeoutId);
        }
        function printCurrentDate() {
            document.getElementById("date").innerHTML = new Date() + "<br>";
        }
    </script>


    <canvas id="myCanvas" width="480" height="320"></canvas>
    <script>
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");

        var timeSpeed = 15;
        var deltaTime = 0.1234;

        // ball Setting
        var ballX = canvas.width / 2;
        var ballY = canvas.height - 30;
        var dx = 1;
        var dy = 1;
        var ballSpeed = 3;

        // Paddle Setting
        var paddleHeight = 10;
        var paddleWidth = 75;
        var paddleX = (canvas.width - paddleWidth) / 2;
        var paddleSpeed = 7;

        // Brick Setting
        var brickRowCount = 3;
        var brickColumnCount = 5;
        var brickWidth = 75;
        var brickHeight = 20;
        var brickPadding = 10;
        var brickOffsetTop = 30;
        var brickOffsetLeft = 30;

        var bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0 };
            }
        }

        // Keyboard boolean
        var rightPressed = false;
        var leftPressed = false;

        var ballRadius = 10;

        var isGameOver = false;

        // Key Click Event
        document.addEventListener("keydown", KeyDownHandler, false);
        document.addEventListener("keyup", KeyUpHandler, false);

        function KeyDownHandler(e) {
            if (e.keyCode == 39) { // right
                rightPressed = true;
                console.log("rightPress 1");
            }
            else if (e.keyCode == 37) { // left
                leftPressed = true;
            }
        }

        function KeyUpHandler(e) {
            if (e.keyCode == 37) { // right
                leftPressed = false;
            }
            else if (e.keyCode == 39) { // left
                rightPressed = false;
            }
        }

        function WallCollision() {
            let isHit = false;
            // max X
            if (ballX + ballRadius / 2 >= canvas.width && dx > 0) {
                dx *= -1;
                isHit = true;
            }
            else if (ballX - ballRadius / 2 <= 0 && dx < 0) {
                dx *= -1;
                isHit = true;
            }
            else if (ballY + ballRadius / 2 >= canvas.height && dy < 0) {
                dy *= -1;
                isHit = true;
            }
            else if (ballY - ballRadius / 2 <= 0 && dy > 0) {
                dy *= -1;
                isHit = true;
            }
            return isHit;
        }

        function IsGameOver() {
            if (ballY + ballRadius / 2 > canvas.height) {
                return true;
            }
            return false;
        }

        function Init() {
            isGameOver = false;

            paddleX = (canvas.width - paddleWidth) / 2;
            paddleSpeed = 7;

            ballX = canvas.width / 2;
            ballY = canvas.height - 30;

            leftPressed = false;
            rightPressed = false;
        }

        function CollisionDetection() {
            for(let c = 0 ; c < brickColumnCount; ++c) {
                for(let r = 0 ; r < brickRowCount; ++ r){
                    let b = bricks[c][r];
                    console.log("wow1");
                    // // change direction
                    if(ballY > b.y && ballY< b.y + brickHeight) {
                        console.log("wow");
                        dy *= -1;
                    }
                }
            }
        }


        ////////////////// Update ////////////////// ↓
        function Draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ballX += dx * ballSpeed;
            ballY -= dy * ballSpeed;
            WallCollision();
            CollisionDetection();

            isGameOver = IsGameOver()

            if(isGameOver == true) {
                alert("GAME OVER");
                document.location.reload();
            }

            // Move paddle
            if (rightPressed && paddleX + paddleWidth < canvas.width) {
                paddleX += paddleSpeed;
            }
            else if (leftPressed && paddleX > 0) {
                paddleX -= paddleSpeed;
            }


            DrawRect(canvas.width / 2 - 50 / 2, canvas.height / 2 - 50 / 2, 50, 50);
            DrawPaddle();
            DrawCircle(ballX, ballY, ballRadius, 0);
            DrawBricks();
        }
        ////////////////// Update End  //////////////////

        // Functions
        function PaddleSpeedUp(_speed) {
            if (paddleSpeed > 10) {
                return;
            }
            paddleSpeed += _speed;

        }
        function PaddleSpeedDown(_speed) {
            if (paddleSpeed <= 0) {
                return;
            }
            paddleSpeed -= _speed;
        }

        function DrawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    let brickX = (c * (brickWidth + brickPadding)) + brickOffsetLeft;
                    let brickY = (r * (brickHeight + brickPadding)) + brickOffsetTop;
                    DrawRect(brickX, brickY, brickWidth, brickHeight);
                }
            }
        }

        function DrawRect(_x, _y, _w, _h) {
            ctx.beginPath();
            ctx.rect(_x, _y, _w, _h);
            ctx.fillStyle = "#FF0000";
            ctx.fill();
            ctx.closePath();
        }

        function DrawCircle(_x, _y, _radius) {
            ctx.beginPath();
            ctx.arc(_x, _y, _radius, 0, Math.PI * 2, true);
            ctx.fillStyle = "green";
            ctx.fill();
            ctx.closePath();
        }

        function DrawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
        }

        // Object Structure
        var Object = {
            name: "newName",
            position: { x: 0, y: 0, z: 0 }
        }

        var Vector2 = {
            x: 0,
            y: 0
        }

        setInterval(Draw, timeSpeed);
    </script>

</body>

</html>